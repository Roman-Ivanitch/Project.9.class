/*****************************************************************************
 *                            Bridge - Мост 
 *                            Устройство 2
 *                            RX/TX
 *                            Приемник и Передатчик
 *****************************************************************************
 *
 * Автор: Обушенков Алексей Андреевич    
 * Группа в ВК https://vk.com/engineer24
 * Канал на YouTube https://www.youtube.com/channel/UCih0Gcl9IEdkR8deDJCiodg
 * Инженерка Engineering room
 * 
 ***************************************************************************** 
 * Скетч собран по материалам сайта http://docs.blynk.cc/
 *****************************************************************************
 * Модули в составе проекта
 * ESP8266 NodeMCU V3 Lua WIFI (3,75 $) https://goo.gl/GFDYq0
 * 
 *****************************************************************************
 * В чем суть скетча
 * Bridge - Мост
 * Связываем два устройства при помощи Blynk
 * в моем случае это две ESP8266
 * в принимающем устройстве нужно делать обработчик если нам отправленно
 * значение на виртуальный пин к примеру на V2 и V3 (Данные от первого устройства поступают сюда)
 * и выводим значения от V2 на V4, 
 * а с V3 соответственно на V5
 * Отправляем значение с кнопки V6 (Приложение) на первое устройство
 * 
 *****************************************************************************
 * V1 - Занято Виджетом Мост
 * V2 - Сюда принемаем значение int число от первого устройства
 * V3 - Сюда принемаем значение String строку от первого устройства
 * V4 - Зането Value Display выводим int число
 * V5 - Зането Value Display выводим String строку
 * V6 - Занято виджетом кнопка отправляем значения на Первое устройство
 * 
 * PIN D0 (помним что он инвертированный GPIO 16) будет зажигаться при получении данных
 * от первого Устройства
 * Нам не надо ничего добовлять в принимающем устройстве что бы с Устройства 1 напрямую управлять
 * Цифровыми пинами. ШИМ PWM так же доступен
 * 
 *****************************************************************************
 */

/* Comment this out to disable prints and save space */
#define BLYNK_PRINT Serial


#include <ESP8266WiFi.h>
#include <BlynkSimpleEsp8266.h>

// Ваш Токен (Приходит на E-mail). Токен Устройства 2
char auth[] = "Токен Устройства 2";

// WiFi настройки.
// Логин и пароль.
char ssid[] = "Логин";
char pass[] = "Пароль";

// Виджет моста инициализируем. Он занимает один виртуальный пин к примеру (V1)
// Благодаря этому физичискими пинами можно управлять напрямую
// Примеры управляющих строк ниже
WidgetBridge bridge1(V1);

BLYNK_WRITE(V2) //Принимаем значение
{
  int pinData = param.asInt(); // Считываем значение и сохраняем в переменную
  Blynk.virtualWrite(V4, pinData); // Выводим в приложение
}

BLYNK_WRITE(V3) // Принимаем значение
{
  String Data1 = param.asStr();
  Blynk.virtualWrite(V5, Data1); // Выводим в приложение
}

// на пин V6 сажаем кнопку (switch)
BLYNK_WRITE(V6) // Принимаем значение от приложения
{
  int Data2 = param.asInt();
  bridge1.virtualWrite(V7, Data2); // Отправляем на первое устройство
}
    /////////////////////////////////////////////////////////////////////////////////////////
    //  Имейте в виду, что при выполнении virtualWrite с bridge мост,
    //  второе устройство нужно обрабатывать входящую команду.
    //  Это можно сделать с помощью этого обработчика на второй доске:
    //
    //    BLYNK_WRITE(V5){
    //    int pinData = param.asInt(); // pinData variable will store value that came via Bridge
    //    }
    //
    //    Используйте знакомые функции для управления другим устройством:
    //    bridge.digitalWrite(8, HIGH)
    //    bridge.digitalWrite("A0", LOW) // <- цель должна поддерживать имя пина "Named pins"
    //    bridge.analogWrite(3, 123) // ШИМ PWM
    //    bridge.virtualWrite(V1, "hello") // Отправляем строку
    //
    /////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Фактические значения передаются в виде строк,
    //  поэтому нет никакого практического ограничения на данные, которые могут быть отправлены.
    //
    //  param.asInt(); целое число -32 768 до 32 767 int занимает 2 байта памяти
    //
    //  param.asFloat(); Числа с плавающей запятой от -3.4028235E+38 до 3.4028235E+38.
    //                   Переменная типа float занимает 32 бита (4 байта) в памяти
    //
    //  param.asDouble(); Тип данных double, в отличие от большинства языков программирования,
    //                    имеет ту же точность, что и тип float и занимает также 4 байта памяти
    //
    //  param.asStr(); строки
    //
    /////////////////////////////////////////////////////////////////////////////////////////

BLYNK_CONNECTED() {
  bridge1.setAuthToken("Токен Устройства 1"); // Сюда пишем Токен Первого устройства
}
  
void setup()
{
  // Debug console
  Serial.begin(9600);

  Blynk.begin(auth, ssid, pass);
}

void loop()
{
  Blynk.run();
}

